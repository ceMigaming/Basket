package com.ocado;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Function;
import java.util.stream.Collectors;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

/**
 * BasketSplitter class is the main class used to split different products across different
 * transport groups using as least of those groups as possible. This is a special case of Set Cover
 * problem (NP-Complete) and to solve it this class uses the fact that there are only 10 different
 * ways of transport allowed and 100 items in basket at the same time, which produces the worst case
 * of about 2^10*100 or approx 100k combinations. First idea was to use quicker approximate
 * algorithm but after further examination of the problem this algorithm seemed like a better
 * solution. This class generates all possible combinations of groups for all items and selects the
 * optimal one.
 * 
 * @author Maciej Chamera
 */
public class BasketSplitter {

    // map containing data from config file.
    private final Map<String, List<String>> config;

    /**
     * Constructor for BasketSplitter class Creates a list of.
     * 
     * @param absolutePathToConfigFile path to the json config file (<code>config.json</code>).
     * @throws IOException when config file can not be found.
     */
    public BasketSplitter(final String absolutePathToConfigFile) throws IOException {
        Gson gson = new Gson();
        Type configMapType = new TypeToken<Map<String, List<String>>>() {}.getType();
        config = gson.fromJson(IOUtils.loadFileAsString(absolutePathToConfigFile), configMapType);
    }

    /**
     * Method used to split items across the least number of groups.
     * 
     * @param items list of items to be split.
     * @return map in which groups are keys and lists of items are values.
     */
    public final Map<String, List<String>> split(List<String> items) {
        List<List<String>> allCombinations = getAllCombinations(items);

        // find combinations with minimum number of groups.
        int minUsedGroups = Integer.MAX_VALUE;
        for (List<String> combination : allCombinations) {
            minUsedGroups = Math.min(minUsedGroups, countUsedGroups(combination));
        }


        // find combination where largest group has the most items.
        int maxOccurrences = 0;
        List<String> optimalCombination = null;
        for (List<String> combination : allCombinations) {
            if (countUsedGroups(combination) == minUsedGroups) {
                Entry<String, Long> entry = combination.stream()
                        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                        .entrySet().stream().max(Entry.comparingByValue()).get();
                if (entry.getValue() > maxOccurrences) {
                    maxOccurrences = entry.getValue().intValue();
                    optimalCombination = combination;
                }
            }
        }

        // build the map from lists.
        Map<String, List<String>> finalItemsMap = new HashMap<>();
        for (int i = 0; i < optimalCombination.size(); i++) {
            List<String> itemsInGroup =
                    finalItemsMap.getOrDefault(optimalCombination.get(i), new ArrayList<>());
            itemsInGroup.add(items.get(i));
            finalItemsMap.put(optimalCombination.get(i), itemsInGroup);
        }
        return finalItemsMap;
    }

    /**
     * Generates all possible combinations with given constrains using
     * <code>findCombinationsRecursive</code> method.
     * 
     * @param items list of all items in basket.
     * @return list of all combinations generated by this method, combinations are stored in a list
     *         where each index corresponds to given item and each value is a group name.
     */
    private final List<List<String>> getAllCombinations(List<String> items) {
        List<List<String>> allCombinations = new ArrayList<>();
        findCombinationsRecursive(items, new ArrayList<>(), allCombinations, 0);
        return allCombinations;
    }

    /**
     * Generates all possible combinations with given constrains using recursion, shouldn't be used
     * outside of <code>findCombinations</code> method. The way it works is by generating all
     * available groups for each item in every step of recursion.
     * 
     * @param items list containing all items in basket.
     * @param currentCombination list of groups used in current combination.
     * @param allCombinations list of all combinations.
     * @param index index of recursion.
     * @see BasketSplitter#findCombinations(List, List) findCombinations.
     * @throws IllegalArgumentException if encountered an item which is not in the config file.
     */
    private final void findCombinationsRecursive(List<String> items,
            List<String> currentCombination, List<List<String>> allCombinations, int index)
            throws IllegalArgumentException {
        // are we in the final recursion step? if yes then add combination to the `allCombinations`
        // list.
        if (index == items.size()) {
            allCombinations.add(new ArrayList<>(currentCombination));
            return;
        }

        String currentItem = items.get(index);
        List<String> groupsForItem = config.get(currentItem);

        if (groupsForItem == null)
            throw new IllegalArgumentException("Item: '" + currentItem + "' not found in config!");

        // foreach available group for this item we generate all possible combinations.
        for (String group : groupsForItem) {
            currentCombination.add(group);
            findCombinationsRecursive(items, currentCombination, allCombinations, index + 1);
            currentCombination.remove(currentCombination.size() - 1);
        }
    }

    /**
     * Counts how many groups given combination uses.
     * 
     * @param combination the combination to count groups for.
     * @return count of groups used in combination.
     */
    private static final int countUsedGroups(List<String> combination) {
        return (int) combination.stream().distinct().count();
    }

}
